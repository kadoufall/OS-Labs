## Q1
- 首先因为每个中断的处理过程不一样，有的需要返回中断前的程序，有的不需要，所以写在一起就会有很多判断
- 不同中断的特权级别不一样，全部写到一个处理函数中的话，就得将特权级别全部设为`3`，然后再进行判断，这很麻烦

---

## Q2
- 因为当前系统是处于用户态的，即特权级别是`3`。而`T_PGFLT` 要求`DPL=0`，即需要内核态下触发。于是用户态触发这个中断直接引起了`general protection fault`，这就是`trap 13`
- 而我们可以通过设置`SETGATE(idt[T_PGFLT], 0, GD_KT, t_pgflt, 3);`使得用户态也可以触发这一中断。但这样就将内存管理接口泄漏给用户态，会引起系统的不稳定

---

## Q3
- 在设置`SETGATE(idt[T_BRKPT], 0, GD_KT, t_brkpt, 3);`的最后一个参数为`3`的时候，表示设置为用户态可触发，此时触发该中断即为`breakpoint fault`
- 若设置为`0`，则表示在内核态才可以触发，而当系统运行在用户态的时候，触发该终端就会导致`general protection fault`

---

## Q4
- 这样的机制使得用户态只能触发系统调用和断点，保证了操作系统的稳定