Exercise 3
1. 从实模式切换到保护模式首先需要加载全局描述符表格寄存器GDTR并设置控制寄存器cr0的保护位,即下列四行指令

0x7c1e: lgdtw 0x7c64
0x7c23:      mov    %cr0,%eax
0x7c26:      or     $0x1,%eax
0x7c2a:      mov    %eax,%cr0

完成切换执行的指令是 0x7c2d: ljmp $0x8,$0x7c32，这条指令后的指令就在32-bits模式下执行


2. boot loader执行的最后一条语句是

((void (*)(void)) (ELFHDR->e_entry))();
7d63:	ff 15 18 00 01 00    	call   *0x10018

这条指令后即跳转到内核的起始语句处，而内核的起始语句为movw $0x1234, 0x472

3. 第2问中已经有解答：内核的起始语句为movw $0x1234, 0x472


4. Boot loader通过ELF header中Program Header Table知道当前有多少个段以及每个段的具体信息。通过这些信息可以循环地将段读入内存中

==============================================================================================================

Exercise 8
1. console.c除了被static修饰的静态函数外的其他函数都可以被其他文件所用
printf.c利用了console.c的cputchar()函数，并用putch()对其进行了包装以记录输出的字符数


2. 这里console的屏幕最大显示为80*25，也就是说CRT_SIZE=80*25，crt_pos是下一个要打印的字符的位置， 当前如果超过了最大的显示位置，
就得把页面上移一行。memcpy就是进行依次复制操作，然后将最后一行除了第一位置零。

3. fmt指向最终显示的字符串，这里是x %d, y %x, z %d\n。而ap是va_list类型的，指向所有输入参数的集合。
执行顺序如下：

vcprintf() *fmt = "x %d, y %x, z %d\n"   ap -> {1,2,3}
cons_putc('x')
cons_putc(' ')
va_arg()  ap_before -> {1,2,3}  ap_after -> {2,3}
cons_putc('1')
cons_putc (' ')
cons_putc ('y')
cons_putc (' ')
va_arg()  ap_before -> {2,3}  ap_after -> {3}
cons_putc('3')
cons_putc (' ')
cons_putc ('z')
cons_putc (' ')
va_arg()  ap_before -> {3}  ap_after -> {}
cons_putc ('4')
cons_putc ('\n')


4. 输出结果为He110 World，执行顺序如下
vcprintf() *fmt = "H%x Wo%s"   ap -> {57616, 0x72,0x6c,0x64,0x00}
cons_putc('H')
va_arg()  ap_before -> {57616, 0x72,0x6c,0x64,0x00}  ap_after -> {0x72,0x6c,0x64,0x00}
cons_putc('e')
cons_putc('1')
cons_putc('1')
cons_putc('0')
cons_putc(' ')
cons_putc('w')
cons_putc('o')
va_arg()  ap_before -> {0x72,0x6c,0x64,0x00}  ap_after -> {0x6c,0x64,0x00}
cons_putc('r')
va_arg()  ap_before -> {0x6c,0x64,0x00}  ap_after -> {0x64,0x00}
cons_putc('l')
va_arg()  ap_before -> {0x64,0x00}  ap_after -> {0x00}
cons_putc('d')
va_arg()  ap_before -> {0x00}  ap_after -> {}

如果在大端机上，i应该变为unsigned int i = 0x726c6400;。而57616不需要改变


5. x=3 y=-267380292或x=3 y=-267380292或其他值。 会输出不确定是值，打印的4个字节是堆栈上的指令或者数据，但是由于格式化输出，所以只会是一个整数

6. 如果编译器改变了压栈的顺序，不需要改变cprintf函数。需要改变的是va_start, va_arg等宏的实现，使其按照先前相反的顺序得到新地址即可







